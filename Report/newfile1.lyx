#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_numerical
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\headheight 3cm
\headsep 3cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Ten Tips on how to Play with a Hamster
\end_layout

\begin_layout Author
Julia Adamsson 880310
\begin_inset Newline newline
\end_inset

Ann Michélsen 890809
\begin_inset Newline newline
\end_inset

Peter Holm 871103
\begin_inset Newline newline
\end_inset

Jakob Martinsköld 870607
\begin_inset Newline newline
\end_inset

Andreas Eklund 890220
\begin_inset Newline newline
\end_inset

Jérémy Tuloup 901026
\end_layout

\begin_layout Abstract
This report reflects the work done by a group of students in the course
 Simulation Engines.
 The task was that each group member were supposed to integrate components
 into an already existing simulation engine, and extend it with non-trivial
 extensions.
 Finally a tech demo was made, showing of the features that was implemented.
 This particular group was focusing on creating modular extensions of behavioral
 AI, pathfinding AI, graphics, camera graphics, physics and software engineering.
 These extensions were then iteratively integrated with each other, resulting
 in a tech demo as the product at the end of the project.
 
\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
In this project a game engine was made as a part of the course Simulation
 Engines in the master programme Interaction Design and Technologies at
 Chalmers University of Technology.
 The engine is built in Unity 3D for which we have made a number of extensions
 with certain goals described further down.
\end_layout

\begin_layout Standard
To show the game engine a tech demo game was made; Ten Tips On How to Play
 With A Hamster which is a physics centered casual single player game, where
 the player uses gravity to make a ball roll around trying to kill as many
 dwarves as possible.
 The game is set in the dwarves home town, a subterranean maze, where the
 dwarves live and work while trying to avoid the murderous ball (the player).
 
\end_layout

\begin_layout Subsection
Purpose 
\end_layout

\begin_layout Standard
The purpose of this project has been to create extensions for Unity 3D,
 in order to make a simulation engine (game engine).
 Since Unity arguably is a game engine in itself, providing developers with
 a lot of pre made features and functionality in order to streamline the
 development process, effort has been put into facilitating as few as the
 built-in things as possible.
 This is since a simulation engine is supposed to be made and not a game.
\end_layout

\begin_layout Standard
To summarize the purpose of the project is to create a simulation engine
 in Unity where the main functionality is implemented as custom made extensions.
 
\end_layout

\begin_layout Subsection
Goals 
\end_layout

\begin_layout Standard
Apart from the goals that arise naturally from the above purpose, the goals
 are mainly about achieving the following things:
\end_layout

\begin_layout Itemize

\series bold
High level of generality
\series default
: the extensions made for the engine should be easy to apply in other projects.
 
\end_layout

\begin_layout Itemize

\series bold
High level of modularity
\series default
: the extensions should be as modular as possible and not dependant upon
 each other.
 Extensions should be possible to take away and/or modify without breaking
 the engine.
 
\end_layout

\begin_layout Section
Pre-study 
\end_layout

\begin_layout Standard
Briefly about relevant literature both within Unity and the different extensions
 Talk about thing we read
\end_layout

\begin_layout Standard
To be able to create a game engine in Unity pre study was made both within
 Unity and within the different extension parts that was made.
 For more information about the extensions see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:division"

\end_inset

.
\end_layout

\begin_layout Standard
In order to learn the basics of Unity 3D there are many tutorials.
 For instance this playlist on Youtube, made by a person calling himself
 “Quill18”: 
\begin_inset CommandInset citation
LatexCommand citep
key "quill18"

\end_inset


\end_layout

\begin_layout Standard
In order to generate a good maze, some pre-study about mazes was needed.
 There is a wealth of information about this and similar problems online,
 for example 
\begin_inset CommandInset citation
LatexCommand citep
key "mazes"

\end_inset

, which was used for this project.
\end_layout

\begin_layout Standard
There are a lot of resources about AI and pathfinding in games on the Internet,
 and also some relevant literature, such as 
\begin_inset CommandInset citation
LatexCommand citep
key "ai-games2"

\end_inset

.
 In this book, there is a detailed part about pathfinding, world representations
 and optimizations.
 It was really helpful to have a good idea of what can be done and how to
 do it.
 A brief review of the A* algorithm was also necessary.
\end_layout

\begin_layout Standard
High level behavioral AI methods such as behavior trees are also covered
 in 
\begin_inset CommandInset citation
LatexCommand citep
key "ai-games2"

\end_inset

, other sources on behavior trees used in this project include 
\begin_inset CommandInset citation
LatexCommand citep
key "champandard,knafla"

\end_inset

.
\end_layout

\begin_layout Standard
Within physics some pre study had to made within how Unity handles physics
 events; the different classes Unity uses as well as what Unity does provide
 and what it do not.
 There also had to be looked into how others had made destructible objects
 before, both in Unity and in general.
 A lot was read about meshes and tutorials about how to create and use them
 was gone through.
 Knowledge also had to be refreshed within some linear algebra, like vector
 mathematics to be able to use the meshes in a good way.
 
\end_layout

\begin_layout Subsection
How does the system look today? 
\end_layout

\begin_layout Standard
Unity is a multiplatform game development tool and game engine
\begin_inset CommandInset citation
LatexCommand citep
key "unity3d"

\end_inset

.
 It has a graphics engine that uses a number of different APIs such as Direct3D
 and OpenGL.
 Unity has a scene view where basic 3D models can be built and more advanced
 model can be imported from e.g.
 Maya or 3DStudioMax.
 It uses the shader language ShaderLab which can be used to program different
 kinds of shaders, however Unity also provide default shaders.
 Nvidia’s PhysX physics engine is used to simulate physics, with all features
 added to an object by adding a rigidbody to it.
 The toolchain is connected through the Unity scene editor.
 Scripting is handled through a variety of different languages, including
 C# and an ECMA-script dialect.
 The default scripting tool is MonoDevelop.
\end_layout

\begin_layout Standard
Unity uses a component based architecture (X has Y relationship), meaning
 that mostly objects in a scene are given components such as user defined
 scripts, materials, physics properties etc.
 All scripts that can be used as Unity components derive from the MonoBehaviour
 class (in turn derived from the base class of all Unity components - Component)
, which handles all interaction between scripts and the Unity engine 
\begin_inset CommandInset citation
LatexCommand citep
key "unity3d-docs"

\end_inset

.
 A simplified definition of MonoBehaviour would be an object which can be
 attached as a component on a GameObject, and can receive updates from the
 Unity engine.
\end_layout

\begin_layout Subsection
What did you want to make better? 
\end_layout

\begin_layout Standard
Unity already acts like a game engine and provides the tools and resources
 needed to make a game.
 To extend the Unity game engine, in this project a number of themes was
 chosen such as AI, graphics and physics, to be extended with things Unity
 does not provide or something that can only be found in their Pro-version.
 Alternately, something that Unity actually already provide but a custom
 built version of it.
 Therefore, extensions were chosen within the Software Engineering, AI,
 graphics and physics fields.
\end_layout

\begin_layout Standard
The software engineering included making a command interface to the specific
 game engine made in this project to be able to make sure that the modules
 we create remain modular (reusable).
 The command interface is mainly focused on creating a bridge between the
 behaviour AI, the player and the game itself.
 Because of this extension, the goal was that it would allow the AI to easily
 be replaced by a human player and vice versa, without needing to change
 much in the code.
\end_layout

\begin_layout Standard
Another extension related to software engineering that we wanted to add
 was a maze generator, that somehow generated a nice maze each time the
 game was started.
 This would allow for more replayability.
\end_layout

\begin_layout Standard
In the AI category, two extensions were made: a behavior part and a pathfinding
 part.
 There are several frameworks in Unity for handling high level behavioral
 AI, most notably the framework Behave 
\begin_inset CommandInset citation
LatexCommand citet
key "behave-framework"

\end_inset

, an implementation of a common AI abstraction called behavior trees 
\begin_inset CommandInset citation
LatexCommand citet
key "knafla"

\end_inset

 that is available at no fee on the Unity asset store.
 The goal was to make a new implementation which has a base non-specific
 to Unity.
\end_layout

\begin_layout Standard
The free version of Unity does not support any tool to do some kind of pathfindi
ng.
 So the idea was to design an extension to compute shortest paths on a map,
 using navigation meshes, with the same kind of feature provided by the
 pro version.
\end_layout

\begin_layout Standard
The graphics part was also split, one part handled the camera movement and
 different camera effects such as making the camera shake when a wall was
 destroyed.
 The second part had more of a focus on environmental effects such as making
 paths in the terrain during game play.
 This is something that is not included in Unity at the moment.
\end_layout

\begin_layout Standard
The last extension was a physics extension.
 Since Unity already has a physics engine which handles gravity, collision
 detection and such the physics extension was chosen to handle something
 specific that Unity does not already provide.
 Thus, it was concluded to do destructible objects; mainly cubes that are
 destroyed in parts that are not made up of pre-made geometry but rather
 the destroyed parts calculated in real time.
 
\end_layout

\begin_layout Subsection
Project plan 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 1 (4)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Find a group, start talking about what to do.
 Individual pre-study about Unity and
\end_layout

\begin_layout Plain Layout
within the chosen extension field.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 2 (5)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final decision about what to do, present concept before class.
 Set up git-repo.
\end_layout

\begin_layout Plain Layout
Keep going with pre-study within chosen extension and start implementing
 if possible.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 3 (6)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Individual implementation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 4 (7)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Individual implementation and mid-course presentation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 5 (8)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start integration of the different parts
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 6 (9)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Keep on integrating as well working on individual parts as well as work
 with the 
\end_layout

\begin_layout Plain Layout
workshop assignment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 7 (10)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final touch, prepare presentation and start with group report
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Week 8 (11)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write group report and individual report 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Project plan
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Division of themes 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:division"

\end_inset


\end_layout

\begin_layout Standard
The extension for this game engine was divided in six parts, mainly based
 on what the group members felt would be interesting or wanted to learn
 more within.
 The extensions are as follows including the responsible person.
\end_layout

\begin_layout Itemize
Software Engineering - Andreas Eklund
\end_layout

\begin_layout Itemize
Artificial intelligence, behavior - Peter Holm 
\end_layout

\begin_layout Itemize
Artificial intelligence, pathfinding - Jerémy Tuloup 
\end_layout

\begin_layout Itemize
Camera centered graphics - Jacob Martinsköld 
\end_layout

\begin_layout Itemize
Graphics, terrain paths - Ann Michélsen 
\end_layout

\begin_layout Itemize
Physics, destructible objects - Julia Adamsson 
\end_layout

\begin_layout Section
Specification of demands 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:spec"

\end_inset


\end_layout

\begin_layout Standard
In this section the functional and and non-functional demands is described
 for each extension.
 
\end_layout

\begin_layout Subsection
Software Engineering 
\end_layout

\begin_layout Standard
The basis for this extension is to implement a command interface for the
 game.
 All actions that either the NPC:s or the player(s) makes should go via
 this command interface.
 This will make the AI and user independent from the rest of the application.
 The functional requirements are:
\end_layout

\begin_layout Itemize
Making it possible for the AI or the GUI programmer to use only the command
 interface when either the player or the AI are performing actions (like
 moving, using items etc) 
\end_layout

\begin_layout Itemize
Checking whether or not a certain action is allowed before trying to perform
 it.
 
\end_layout

\begin_layout Itemize
Optionally letting the command user know if an action is allowed or not.
\end_layout

\begin_layout Standard
The non-functional demands is that the command interface should be easy
 to use, while also performing efficiently enough when needed.
 It should also be generic enough to not be dependant on this specific implement
ation, but allow different kinds of implementations and changes in the general
 game design.
 
\end_layout

\begin_layout Subsubsection
Maze generator 
\end_layout

\begin_layout Standard
The maze generator extension is able to both generate a random looking maze,
 and also handle the placement of the walls that build the maze.
 The functional demands are:
\end_layout

\begin_layout Itemize
Creating a random looking, perfect 2D-maze of any size.
 
\end_layout

\begin_layout Itemize
Place walls of a given type on correct places.
\end_layout

\begin_layout Standard
The non-functional demands are that It should be as modular as possible.
 It should also be efficient, so that it does not take too much time to
 load a new maze each time the game starts.
 
\end_layout

\begin_layout Subsection
AI - Pathfinding 
\end_layout

\begin_layout Standard
The AI-Pathfinding extension should provide a tool to make agents move on
 plane surfaces, along the shortest path.
 The extension role is to generate a navigation mesh, taking into account
 the scene geometry.
 This NavMesh (graph) will be used to perform the computations when searching
 for a path.
 The functional demands are:
\end_layout

\begin_layout Itemize
It should generate its own representation of the map and use its own data
 structure for storing nodes and information needed for the pathfinding.
 
\end_layout

\begin_layout Itemize
Given a start position and an end position, it should compute the shortest
 path between these two points.
 
\end_layout

\begin_layout Itemize
The extension should also provide a basic MovementAgent script to make an
 agent move along a path to a given target position.
\end_layout

\begin_layout Standard
Concerning the non-functional demands, the extension should be able to be
 as modular as possible, in order to be plugged on top of an existing scene
 or project.
 It should also be fast and scalable (should work for small and big maps).
 
\end_layout

\begin_layout Subsection
AI - Behavior 
\end_layout

\begin_layout Standard
The AI behavior extension is meant to provide a general purpose library
 that lets users design and model complex behaviors for independent actors
 in a Unity project.
 The functional demands of this extension are:
\end_layout

\begin_layout Itemize
To enable modeling of complex high level behaviors as well as lower level
 behaviors, down to simple interactions with the game model (e.g.
 moving to a point, interacting with an object).
 
\end_layout

\begin_layout Itemize
To handle these behaviors as an independent component, separate from other
 parts of the game logic.
 
\end_layout

\begin_layout Itemize
To manage all actors of a given type under a given context through one single
 interface.
\end_layout

\begin_layout Standard
Non-functional demands include, but are not limited to: generality (as much
 of the implementation is to be independent of the Unity engine, to enable
 adaptations in other systems; modularity, both within the behavior tree
 structure and within the Unity engine; speed, the behavioral computations
 should take minimal resources to leave room for heavier tasks such as physics
 or pathfinding; ease of use, AI authors should quickly be able to construct
 trees to enable more time to be spent on implementing the low level interaction
s with the engine.
 
\end_layout

\begin_layout Subsection
Camera centered graphics 
\end_layout

\begin_layout Standard
The purpose of this extension is to offer a simple way of moving the camera
 to simulate tilting the world when it is actually only the cameras perspective
 that is changing, as well as providing some simple effects, such as camera
 shake.
\end_layout

\begin_layout Standard
Functional demands of the extension are:
\end_layout

\begin_layout Itemize
Given a Unity Camera and a GameObject, the extension should work in a default
 way (Top down view).
 
\end_layout

\begin_layout Itemize
It should have some easily alterable variables to change things such as
 distance between camera and the object, perspective angle etc.
 
\end_layout

\begin_layout Itemize
Any effects should be triggered in a simple way; just simply by calling
 a function.
\end_layout

\begin_layout Standard
Non-functional demands are that translations and rotations should be smooth
 and “organic” rather than instantly switching between positions and angles.
 It should also be easily extendible and not implemented in a way that might
 make it hard to add more effects etc.
 The extension should be easily integrated with the others in the final
 engine, as well as in others.
 
\end_layout

\begin_layout Subsection
Graphics - Terrain paths 
\end_layout

\begin_layout Standard
This extension will focus on making paths in the terrain after the ball.
 The terrain should be modified in real time.
\end_layout

\begin_layout Standard
This extensions functional demands are:
\end_layout

\begin_layout Itemize
Given the balls position it should be able to dig a hole in the terrain.
 
\end_layout

\begin_layout Itemize
Given the balls position change the texture of the terrain.
 
\end_layout

\begin_layout Itemize
The extension should be able to know which texture the ball is moving on
 and from this information decide which texture that should be used in the
 paths.
\end_layout

\begin_layout Standard
The non-functional demands are that the paths should be made in a way so
 that they do not take too much computational power compared to the visual
 appearance of the effect.
 Therefore it might be of consideration to make the paths look more jagged
 and ugly if that would save a lot of power that could be used in a better
 way elsewhere.
 Since the graphic extensions consists of multiple parts, they should also
 be made in a way so that they easily can be integrated with each other
 and the rest of the game.
 
\end_layout

\begin_layout Subsection
Physics - Destructible objects 
\end_layout

\begin_layout Standard
The physics extension will handle the destruction of simple geometry (with
 main focus on cubes), when a specific object smashes into it.
 It should not be made up of pre-made geometry such many small cubes that
 are built up to a bigger cube, which will then fall apart when a force
 is added to them.
 Rather the destroyed parts will be calculated and created in real-time.
 Functional demands for the the destruction is:
\end_layout

\begin_layout Itemize
The destroyed part must not be made up of pre-made geometry.
 
\end_layout

\begin_layout Itemize
The destroyed parts should be made of meshes calculated based on how the
 object that is destroyed look.
 
\end_layout

\begin_layout Itemize
The extension should also implement collision detection and other physics
 implementations provided by Unity, that decides when the walls are destroyed
 and other such things.
\end_layout

\begin_layout Standard
The non-functional demands are that the implementation should be general,
 modular and easy to build up upon.
 The destruction should also look as realistic as possible given the time
 span for the course.
 
\end_layout

\begin_layout Section
Analysis 
\end_layout

\begin_layout Standard
This chapter is about how the different extensions are connected to the
 game and each other.
 
\end_layout

\begin_layout Subsection
Conceptual model 
\end_layout

\begin_layout Standard
Since it was a non-functional requirement of most of the extensions to be
 modular the group tried to make sure that everyone was only dependent on
 other people’s extension when absolutely necessary.
 The command interface is acting as a guarantee that the player controls
 and behavior AI are acting with the rest of the application in a modular
 fashion.
 All game objects use different script components.
 For instance the Dwarf and Ball objects use Dwarf and Ball scripts, which
 implements IActor interface so that they can be used by the command interface.
 
\end_layout

\begin_layout Subsection
Architecture 
\end_layout

\begin_layout Standard
The general architecture of the application is basically looking like figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:General-architecture-of"

\end_inset

 below.
 The different extensions are working as standalone modules and are usually
 only connected to the rest of the application where needed.
 The command interface acts as the application’s glue between most of the
 extensions and is therefore the only extension that is definitely not modular.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/GeneralArchitectureSimEng.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
General architecture of our application’s different extensions and how they
 are connected to each other.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:General-architecture-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Design 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:design"

\end_inset


\end_layout

\begin_layout Standard
This section will describe the design of the different extensions and the
 classes that have been created.
 
\end_layout

\begin_layout Subsection
Software Engineering 
\end_layout

\begin_layout Standard
The command interface is an interesting way to make sure that the AI and
 player handling remain modular.
 The intention is that everything that a player or AI can do in this game
 should go via interfaces 
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
For the command interface there exists a ICommand interface that all the
 commands implements.
 So all commands have the same two methods (isAllowed() and execute()),
 and the rest is set upon the creation of the command.
\end_layout

\begin_layout Standard
The most important command are the MoveCommand-method which is supposed
 to be used to move objects which implements the IActor interface.
 In this game that will basically only be the dwarves, but since the Ball
 also implements IActor it can also be moved with this command.
\end_layout

\begin_layout Standard
Another important class is the InteractCommand, which takes an IActor and
 an IInteractable (for instance a Bed or a Workstation) and creates an interacti
on between them.
 This interaction is defined by the IInteractable, so that when a Dwarf
 interacts with a bed, the dwarf fall asleep.
 When the dwarf is interacting with a Workstation, it starts to work.
\end_layout

\begin_layout Standard
Other commands include:
\end_layout

\begin_layout Itemize
EmoteCommand, in which a IActor displays some kind of emotion (like fear,
 sleeping “Z”:s etc.) 
\end_layout

\begin_layout Itemize
RollCommand, which starts to apply a force on an object in a certain direction.
 This is intended to be used by the ball, since it will not move in a regular
 fashion.
 
\end_layout

\begin_layout Itemize
PickupItemCommand, which makes sure that a certain IActor picks up items
 that can be found on the ground, for instance powerups.
 Items on the ground are called GroundStuff and can for instance be powerups
 or mines.
 Mines are automatically exploded once a certain type of IActor is close
 enough.
 The types of IActors that can use a certain GroundStuff are defined by
 the GroundStuff itself.
 
\end_layout

\begin_layout Itemize
SoundCommand, which plays a certain sound from a certain location.
 
\end_layout

\begin_layout Itemize
UseItemCommand, which makes sure that a certain IActor uses an item that
 it has in it’s inventory.
 
\end_layout

\begin_layout Itemize
FindInteractableCommand, which finds a suitable IInteractable of the specified
 type for an IActor.
 This is intended to be used for the dwarves AI agent.
\end_layout

\begin_layout Standard
For the maze extension there is only one big class containing all functionality.
 However in order for it to be modular, all generic maze generating should
 probably be in a separate script, while the code that places the walls
 should be in a script that uses the generic maze generation script.
 
\end_layout

\begin_layout Subsubsection
Interaction 
\end_layout

\begin_layout Standard
Since the command interface extension is sort of “gluing” together the AI
 and the rest of the extensions, it makes a lot of use of the other extensions.
 For instance the MoveCommand is making use of the pathfinding extension.
 The object that is being moved, needs to contain both the IActor and the
 MovementAgent scripts.
 
\end_layout

\begin_layout Subsection
AI - Pathfinding 
\end_layout

\begin_layout Standard
The AI-Pathfinding extension is basically made of two modules.
 The first module interacts with the map and the geometry to build or modify
 a graph, and the second module focus on computing the paths.
 
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
The AI-Pathfinding extension has a simple design, which make new features
 easy to add.
 The first part contains the Monobehaviour scripts:
\end_layout

\begin_layout Itemize
TileGraphGenerator: scan and rescan the map to detect obstacles, and build
 an internal graph to represent the walkable areas.
 
\end_layout

\begin_layout Itemize
MovementAgent: a script designed to be attached on an mobile agent.
 The agent is always looking for a target to reach, and when the target
 has been defined, it calls the AStar method from the graph to get a path
 and move along it.
\end_layout

\begin_layout Standard
The second part contains more generic classes to represent a graph and nodes:
\end_layout

\begin_layout Itemize
Graph, TileGraph: Graph is an abstract class, and TileGraph is a possible
 way to represent a graph.
 It is easy to add new map representations, like a more general navmesh,
 by just extending the Graph class.
 
\end_layout

\begin_layout Itemize
Node, TileNode: Node defines the common properties of a node, like the world
 position, but also stores the g and f scores used by the A* algorithm.
 TileNode extends the Node class and add information about the x and z coordinat
es in the graph.
 
\end_layout

\begin_layout Itemize
Path: structure to store.
 It simply extends a List<Vector3>, but can be used as a wrapper to store
 more information.
\end_layout

\begin_layout Subsubsection
Interaction 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/pathfinding-interactions.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TileGraphGenerator is put in our common global scripts object.
 It can be used from everywhere by just performing a GameObject.Find().
 This is how MovementAgent interact to get the graph and compute a path.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
AI - Behavior 
\end_layout

\begin_layout Standard
The behavior extension consists of two main parts.
 The BehaviorTrees C# library, which is independent of the Unity platform,
 and the BehaviorManager, a Unity specific entity manager designed for managing
 and running AI actors.
 
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
The BehaviorTrees library contains many different classes, all of which
 are part of a common hierarchy.
 The 
\series bold
Node
\series default
 class is the common abstract superclass for all behavior tree nodes.
 It handles the basic workings of a behavior tree, i.e.
 storing and reporting a node’s state.
 It has three major abstract subclasses: 
\series bold
Selector
\series default
, which represents branches in the tree, and handles child nodes in different
 ways; 
\series bold
Decorator
\series default
, which has a single child and enables the user to control how this child
 is accessed and how its result is handled; 
\series bold
Leaf
\series default
, which represents nodes with no children.
 A Leaf is either a 
\series bold
Condition
\series default
, which checks game state, or an 
\series bold
Action
\series default
, which handles an actor’s actual interaction with the game model.
 
\end_layout

\begin_layout Standard
The 
\series bold
BehaviorManager
\series default
 is an abstract class designed for creating, managing and destroying AI
 actors.
 Users should extend this class to create managers for specific types of
 actors.
 
\end_layout

\begin_layout Subsubsection
Interaction 
\end_layout

\begin_layout Standard
Interaction with the Unity engine is handled on two levels: the high level,
 making sure the actors’ AI methods are run (through the 
\series bold
RunAI()
\series default
 method in the 
\series bold
IAgent
\series default
 interface) is handled by the BehaviorManager.
 The low-level interactions for each individual actor are handled through
 the Leaf Nodes of the behavior trees.
 Running a behavior tree is done by calling the 
\series bold
Visit()
\series default
 method of its root Node.
 This will execute the Visit() methods of the Node’s children according
 to the type of the root and its children, until a final result has been
 reached.
 
\end_layout

\begin_layout Subsection
Camera centered graphics 
\end_layout

\begin_layout Standard
This extension is all about moving the camera around to look at the player
 from different angles and positions, to give the player the illusion of
 the world tilting.
 
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
The extension is made up from three Unity MonoBehavior script classes, all
 written in C#; CameraScript, RotationMasterScript and PlayerScript.
\end_layout

\begin_layout Itemize
PlayerScript: this class takes input from the keyboard and adds forces to
 the player object (a ball) to make it move around the world.
 Not really part of the extension per se, other than that it provides the
 other classes with how the world should tilt to explain the gravitational
 movement of the ball.
 The script is attached to the player GameObject.
 
\end_layout

\begin_layout Itemize
RotationMasterScript: this is a class which is attached to a meshless Unity
 GameObject, which will follow the players position and rotate in a way
 that simulates the world tilting.
 This RotationMaster object is a parent of the camera, which means that
 the camera will inherit its rotation (and position, but this is overridden).
 This script holds most of the variables used to change properties of the
 cameras behavior such as: camera distance, perspective angle, camera speed
 and amount to tilt.
\end_layout

\begin_layout Itemize
CameraScript: this is the class which does all the mathematical calculations
 to decide where the camera should be positioned to create the illusion
 of the world tilting.
 It is attached to the main camera object.
\end_layout

\begin_layout Subsubsection
Interaction 
\end_layout

\begin_layout Standard
The extension will update the angle and positioning of the camera on each
 frame by calling Unitys transform.position for the camera and transform.rotation
 for the rotation master.
 
\end_layout

\begin_layout Subsection
Graphics - Terrain path 
\end_layout

\begin_layout Standard
As mentioned earlier this extension handles the paths that are created when
 the ball is moving around on the terrain.
 
\end_layout

\begin_layout Subsubsection
Classes 
\end_layout

\begin_layout Standard
This extension is made up of one class called TerrainPath.
 This class is modifying the terrains heightmap and its alphamap given the
 balls position.The TerrainPath class is using Unity’s MonoBehavior.
 There is also a class called PlayerScript that handles the balls movement
 as mentioned earlier.This class also handles when the TerrainPath class
 should be called and when the terrain should be changed.
 
\end_layout

\begin_layout Subsection
Physics - Destructible objects 
\end_layout

\begin_layout Standard
The physics extension handles destruction of objects with focus on cubes.
 The cubes that are destroyed are thought of as walls since a wall is a
 common destruction object in games.
 To be destroyed the walls are made up meshes to look as cubes, thus not
 polygon cubes.
 From the beginning a cube is built up of six faces made up two triangles
 each.
 When it is destroyed the two triangles on the front side is subdivided
 into eight triangles which then represents the parts that the big wall
 is destroyed in.
 
\end_layout

\begin_layout Subsubsection
Classes and interaction 
\end_layout

\begin_layout Standard
There are mainly three classes that handles the creation and destruction
 of meshes, but a few others in total that are important for it to function
 correctly (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-most-important"

\end_inset

).
 All classes are derived from Unity’s MonoBehavior.
 Startscript or MapGenerationScript is used to generate the walls in the
 beginning, where the last mentioned are generating a maze where the walls
 made in WallMeshManagerScript is placed.
 WallMeshManagerScript are handling the creation of both whole walls and
 the destroyed parts with the help of eight vertices which defines the corners.
 WallCollisionScript is called when something collides with a wall, this
 script in turn calls for SubdivideMeshScript which subdivides the walls
 triangles on the front face.
 Finally, WallMeshManager is used again to created the destroyed parts of
 the big wall.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/julia/classdiagram_physics.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-most-important"

\end_inset

The most important classes handling destructible objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:implementation"

\end_inset


\end_layout

\begin_layout Standard
This chapter will give a deeper understanding on how the different extensions
 was implemented.
 The first section will cover the software engineering part, followed by
 the two AI extensions and the graphical extensions.
 The last section will cover the physics extension.
 
\end_layout

\begin_layout Subsection
Software Engineering 
\end_layout

\begin_layout Standard
The command interface works in the following order: Firstly the wanted type
 of command is created.
 After that the user can optionally check if the command is allowed and
 possible by calling the isAllowed-method.
 Finally a call to the execute-method will perform the action (if it is
 allowed).
 These simple steps is basically what is needed in order to use the command
 interface.
\end_layout

\begin_layout Standard
Currently these commands exist and work:
\end_layout

\begin_layout Itemize
MoveCommand, which makes use of the pathfinding scripts to move IActor objects
 in the maze.
 It works splendidly.
 
\end_layout

\begin_layout Itemize
InteractCommand, which is a command that calls the interact-function in
 the IInteractable object.
\end_layout

\begin_layout Itemize
PickupItemCommand, that currently uses the item that is being picked up
 instantly.
 It does so by first adding the item to the IActor object’s inventory and
 then calling the UseItemCommand.
\end_layout

\begin_layout Itemize
UseItemCommand, that calls the use-function of the item carried by a certain
 IActor.
\end_layout

\begin_layout Itemize
FindInteractableCommand, which finds a random IInteractable of a specified
 type.
 The randomness is there to make sure that not all dwarves use the same
 beds or workspaces.
 However it is doubtful that this should be a command, it could possibly
 have been a method in the Dwarf script instead, since it does not change
 any values.
\end_layout

\begin_layout Standard
Roll command was removed due to it being much easier to implement the control
 of the ball in the MovePlayer script instead.
 However it might be solved with another command StartRollCommand, which
 instead would add the MovePlayer script to the specified actor (which would
 be the ball in our current case).
 
\end_layout

\begin_layout Subsubsection
Maze generation 
\end_layout

\begin_layout Standard
For the maze generation extension, the maze is stored as a rather large
 adjacency matrix of size n*n, where ‘n’ is the number of tiles in the maze.
 It could also have been stored as a list.
 The reason to store it as a matrix rather than a list is because it works
 faster when adding or removing edges, and slower than a list when adding
 or removing nodes.
 In this case it will not add or remove nodes (tiles) but rather carve a
 maze using some fancy algorithm.
\end_layout

\begin_layout Standard
The fancy algorithm of choice is a backtracker algorithm which is using
 a stack to keep track of which nodes has been visited earlier and in what
 order.
 Then it starts at a node and “carves” a way into a random neighboring node.
 After that it adds the node that was visited onto the stack.
 When there are no unvisited neighbouring tiles it pops the stack and if
 there are any unvisited neighbouring nodes there.
 When there are no more nodes in the stack the maze is finished.
 
\end_layout

\begin_layout Subsection
AI - Pathfinding 
\end_layout

\begin_layout Standard
The pathfinding extension has to proceed in different steps to ensure that
 a graph is created at the beginning of the game.
 This is why before doing any kind of pathfinding it is necessary to scan
 the entire scene to find obstacles.
 
\end_layout

\begin_layout Subsubsection
Scan of the map 
\end_layout

\begin_layout Standard
Before doing any pathfinding, it is necessary to build a graph to represent
 the map and the walkable/unwalkable areas.
 Then the pathfinding just has to use this representation.
 The graph is creating by raycasting the map from a given height.
 Typically we set the height to 1000, but it can be anything else as long
 as we are on top of everything on the map.
 It is also necessary to get the dimensions of the terrain to put the starting
 point in the bottom left of the terrain.
 
\end_layout

\begin_layout Standard
The width and are the height are specified to give the precision of the
 graph (for example 100x100).
 The raycast algorithm perform a loop on these two parameters to iterate
 over the entire map and produces a Node[width,height] matrix.
 
\end_layout

\begin_layout Standard
Scene objects are put in different layers.
 This is absolutely primordial to be able to detect which objects are obstacles
 and which are not.
 In practice, the terrain is put in the Floor layer and the walls in the
 Obstacles layer.
 If the ray hits an object layered Obstacles, then the corresponding node
 in the graph is set to unwalkable.
 
\end_layout

\begin_layout Standard
There is also a post-process to extend the unwalkable areas.
 This is to prevent the agents from moving too close to the walls.
 This post-process is done by iterating over every cells labeled as obstacles,
 and for each of these obstacles, take the neighbors cells in a given radius
 (2 for example) and put them in a list.
 At the end, all members of the list is labeled as unwalkable.
 
\end_layout

\begin_layout Subsubsection
A* 
\end_layout

\begin_layout Standard
Searching for the shortest path is done using the A* algorithm.
 A* uses the graph representation to get information about walkable and
 unwalkable areas and how to find the neighbors of a given cell.
 The heuristic used is the diagonal shortcut, which seems to be a good compromis
e between performance and accuracy.
 But it is also possible to use the manhattan heuristic which works really
 fine for maze maps.
 
\end_layout

\begin_layout Standard
At the end of the computation, it gives a Path as a parameter to the callback,
 which is simply a List<Vector3>.
 
\end_layout

\begin_layout Subsubsection
Movement agent 
\end_layout

\begin_layout Standard
The MovementAgent script is a basic script, which goal is to move from the
 current position to a target position.
 It can access the TileGraphGenerator by searching for the common scripts
 object.
 Then it uses the the AStar method of the graph.
 
\end_layout

\begin_layout Standard
Once the movement agent has a target and a non-empty path, it simply moves
 until the next point in the path (using the CharacterController component).
 When the distance from the next point to the current position of the agent
 is less than wayPointDistance, the point is considered reached and the
 agent can move to next one.
 
\end_layout

\begin_layout Subsubsection
Rescan of the map
\end_layout

\begin_layout Standard
The introduction of destructible walls finally made the rescan of the map
 absolutely necessary.
 When a wall is destroyed, the Rescan method is called with the parameters
 bottomLeft and topRight to define the position and size of the destroyed
 wall.
 The TileGraphGenerator then gets the corresponding nodes in this area and
 performs a raycast on this area only.
 
\end_layout

\begin_layout Standard
It is necessary to do this raycast because there can be some unwalkable
 cells around which are not obstacles but have been labeled as unwalkable
 by the radius modifier post-process.
 
\end_layout

\begin_layout Subsection
AI - Behavior
\end_layout

\begin_layout Standard
Implementing the BehaviorTrees library and its interface to Unity turned
 out to be a fairly straight forward task, the designed interfaces could
 be used in their entirety.
\end_layout

\begin_layout Subsubsection
The BehaviorTrees library 
\end_layout

\begin_layout Standard
The implementation of the BehaviorTrees library follows the structure outlined
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:design"

\end_inset

.
 To minimize the amount of project-specific subclassing required by the
 user, all functionality accessing anything outside the data structure itself
 is handled using delegate properties.
 
\end_layout

\begin_layout Standard
The Node class contains an enum type Status, which is used as the return
 type for the Visit() method, to report the results of executing a Node.
 It is also reported as a property State, to let other Nodes know about
 the result of previous executions of the Node.
 
\end_layout

\begin_layout Standard
Selector and Decorator Nodes come in a large variety of different versions
 which, apart from the properties stated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:spec"

\end_inset

, have few properties in common with each other.
 The specific details of these different implementations will not be covered
 here.
 
\end_layout

\begin_layout Standard
Condition Nodes are fed a Func<bool> delegate (an arbitrary function with
 a bool return type) and returns success or failure depending on the result
 of calling this function.
 
\end_layout

\begin_layout Standard
Action Nodes have their behavior defined by a Func<Status> delegate, which
 interacts with the underlying engine and returns a result of this interaction.
 In the case of non-immediate interactions (such as moving to a spot), Action
 Nodes provide a callback method to be called by the system when the interaction
 is complete (e.g.
 the actor has reached its destination).
 
\end_layout

\begin_layout Subsubsection
Interfacing with Unity 
\end_layout

\begin_layout Standard
As mentioned above, low level interactions with the game engine is handled
 by the user writing custom delegate functions to this end.
 Higher level engine specific functionality, such as functions for getting
 the current time is also handled this way.
 
\end_layout

\begin_layout Standard
The responsibility of keeping track of actors belongs to BehaviorManager
 and its subclasses.
 A BehaviorManager has several components of interest.
 A GameObject property set in Unity’s Inspector contains the prototype GameObjec
t for the actors to be created and managed.
 Methods for spawning or decommissioning actors of the managed type are
 provided.
 Actors are stored in a C# Dictionary, for which users can either provide
 their own key values manually or use the abstract method 
\series bold
GetUniqueKey()
\series default
.
 This method can be used to define rules for when spawning an actor is legal,
 by returning null values when spawning is not allowed.
\end_layout

\begin_layout Subsection
Camera centered graphics 
\end_layout

\begin_layout Standard
Upon initiation the scripts execute their respective Start-methods, setting
 some default values for variables, finding and assigning relevant GameObjects
 etc.
 The rest of the time the scripts apart from PlayerScript execute in the
 LateUpdate-methods, called each frame.
 PlayerScript instead executes in the FixedUpdate-method, to prevent player
 movement to be dependant on current frame rate.
\end_layout

\begin_layout Standard
This is what happens on each frame: 
\end_layout

\begin_layout Subsubsection
RotationMasterScript 
\end_layout

\begin_layout Standard
The current final rotation is calculated by checking what kind of force
 is applied to the player at the moment.
 When this desired rotation has been calculated, the rotation is spherically
 linearly interpolated between the current rotation and the desired rotation
 by using the Quaternion.Slerp function.
 How fast this interpolation is, is specified by a variable called animationSpee
d.
 
\end_layout

\begin_layout Subsubsection
CameraScript 
\end_layout

\begin_layout Standard
The amount to tilt and the camera distance variables are read from the rotation
 master, since these can be changed at runtime.
 Then the desired end position of the camera is calculated based on the
 current direction of force applied to the player, the camera distance and
 the amount to tilt.
 This is done using standard trigonometric math in the following way: 
\begin_inset Newline newline
\end_inset


\family typewriter
x = (player’s x-coordinate) + (camera distance) * sin((horizontal tilt)
 * (amount to tilt)) 
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
y = (player’s y-coordinate) + (camera distance) * cos(((vertical tilt) *
 (amount to tilt)) 
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
z = (player’z z-coordinate) + (camera distance) * sin((vertical tilt) *
 (amount to tilt)) + sin((perspective angle) * (camera distance))
\family default
 
\begin_inset Newline newline
\end_inset

where the horizontal and vertical tilt variables are either -1, 0 or 1 at
 any given time, depending on the current direction of force applied to
 the player.
 A graphical model for how this is done can be seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-model-of"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/Section_6.4_trigonometric_illustration.png
	scale 25

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-model-of"

\end_inset

A model of how the position of the camera in relation to the player is calculate
d.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The cameras position is then linearly interpolated between the current and
 desired position by using the Vector3.Lerp function, again using the animationSp
eed variable to determine quickness.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/Section_6.4_screenshot.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Final in-game result of the tilting camera.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Graphics - Terrain paths 
\end_layout

\begin_layout Standard
The terrain paths is created by modifying the build in terrain that exists
 in Unity.
 The terrain is modified in two ways, the heightmap and the alphamap.
 The height map is modified to make a hole or groove so that it will look
 like the ball is digging its way in the ground.
 Similar to how it looks when a big snowball is created.
 The alphamap is modified to change the texture of the terrain.
 So the paths could be made in another texture than the rest of the ground
 if that is preferred, for example if the ball is rolling on a texture made
 of grass it might look good to change this texture in the paths to one
 that contains mud.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/terrainPath picutre.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Paths made on grass texture 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Heightmap and Alphamap 
\end_layout

\begin_layout Standard
To modify the heightmap and the alphamap the balls position first has to
 be transformed from the world coordinate system to terrain coordinates.
 This is done by first subtract the balls world coordinate position with
 the terrain transformed position.
 Then this value has to be divided with the terrains size, this gives a
 position between zero and one.
 Then to get a position that could be used to set the new heightmap this
 value has to also be multiplied with the resolution of the heightmap and
 last converted to integer.
 The paths is then created by making a circle (more like a flat sphere)
 at the balls position.
\end_layout

\begin_layout Standard
In the beginning of the script a backup of the heightmap is stored.
 This is then reloaded when the application is closed.
 This has to be done because otherwise the terrain is not set back to a
 flat terrain, but will contain all the paths from the previous game in
 the new game.
\end_layout

\begin_layout Standard
The terrain script is called every third frame.
 If it is called every frame performance issues will occur.
 The paths could be made so that they almost had no impact on the performance.
 Then the resolution of the heightmap and the detailed resolution (texture)
 has to be lowered.
 The problem with this is that the paths will then become bigger and uglier
 since the terrain is not that detailed anymore.
 
\end_layout

\begin_layout Subsubsection
Terrain paths in Unity 
\end_layout

\begin_layout Standard
The script terrainPath is added as a child to the terrain that is created
 in the scene.
 The script can be changed in different ways from the inspector view, which
 means that the script do not have to be opened but can be tweaked and changed
 from within Unity.
 There is six different variables the first two specifies the texture that
 should be used in the paths.
 This is specified as an integer value representing the index of the texture.
 The second two variables is the textures that is used on the ground, these
 are needed for the script to know if the ball is traveling on grass or
 another texture.
 Last there is two float values that specifies the size of the hole that
 will be digged after the ball and the size for the path texture.
 
\end_layout

\begin_layout Subsection
Physics - Destructible Objects 
\end_layout

\begin_layout Standard
As mentioned in previous parts of the report the physics extension handles
 destructible objects with focus on destructible walls with cube form.
 For the creation and destruction of these walls mainly three classes are
 used; WallMeshManagerScript, WallCollisionScript and SubDivideMeshScript.
 
\end_layout

\begin_layout Subsubsection
Creation of walls 
\end_layout

\begin_layout Standard
Walls are made up a mesh, defined by eight vertices building a cube figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-mesh-cube"

\end_inset

.
 A mesh is used to define a destructible object because it can be modified
 from script.
 Each vertice is defined by a x-, y- and z-value and the eight vertices
 are put in an array which defined the six different faces bottom, left,
 front, back, right and top.
 For example in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-mesh-cube"

\end_inset

 one of the faces are made up of the vertices P4, P5, P1 and P0.
 Since meshes are built of triangles at least two triangles must define
 each face; in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-mesh-cube"

\end_inset

 the blue line separates the two triangles made of P1, P4, P5 and P1, P0,
 P4.
 The triangles are defined by an int-array simply with indices to the array
 with the vertices.
 To each mesh an array with normals and an array with UV-values are included,
 these are used so that the front side of the mesh is facing the camera
 keeping it from being back faced culled and for UV-mapping so that the
 texture on the walls will look good.
 These are then put together by using Unity’s Mesh class and its variables,
 and added to an empty gameObject’s Meshfilter component.
 The wall gameObject is also equipped with a box collider and not a mesh
 collider since these are not as computationally heavy and because it is
 known they look as boxes anyway.
 This collider will get the event that something is colliding with the wall.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/julia/mesh_vertices.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-mesh-cube"

\end_inset

A mesh cube made of eight vertices 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Destruction of Walls 
\end_layout

\begin_layout Standard
For this project, the walls that are created are not supposed to be destructible
 all the time.
 Therefore, when they are created they do not have the script components
 that makes them destructible.
 This is handled by a script named Ball, which is a script attached to a
 ball and the object that in this project is used for destroying walls.
 Thus, when the ball gets the event the it is colliding with a wall it iterates
 through all the wall objects in the scene and adds the scripts to every
 wall that makes them destructible; WallCollisionScript and SubdivideMeshScript.
\end_layout

\begin_layout Standard
WallCollisionScript handles the collision, what it does is calling for a
 MySubdivide in the SubdivideMeshScript which changes the front side of
 the wall to made of eight triangles instead of two (each two made to four
 new).
 This works as follows; consider the wall part shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Subdivision"

\end_inset

.
 The upper triangle is from the beginning defined by the vertices P0, P1
 and P3.
 To subdivide this triangle into four triangles three new vertices need
 to be calculated b, c and d shown in the figure.
 These are calculated with simple vector mathematics:
\family typewriter

\begin_inset Newline newline
\end_inset

b = (P1 + P0) / 2 
\begin_inset Newline newline
\end_inset

c = (P3 + P1) / 2 
\begin_inset Newline newline
\end_inset

d = (P3 + P0) / 2
\end_layout

\begin_layout Standard
By means of these three new vertices together with the three old ones, the
 four new triangles are defined; P3, c, d and d, c, b and so on.
 The same is done for the lower triangle.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/julia/mesh_dividedwireframe2.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Subdivision"

\end_inset

Subdivision
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the walls front face has been subdivided WallMeshManager takes care
 of the destruction, or ratherit is creation of eight new parts and then
 the big wall is simply removed.
 WallMeshManager traverse through the triangle array to get the nine vertices
 that makes up the eight triangles that defines the wall’s front face.
 The three vertices defining each triangle are then used as a base to create
 a new wall part that looks like a destroyed part from the big wall.
 To do this the vertices P0, P4 and P5 (from figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-mesh-cube"

\end_inset

) which defines a mesh cube are set to the three vertices defining one small
 triangle, then the rest of the vertices are derived from these but moved
 a slight bit to make the triangle get volume and look like it is actually
 a part from the big wall..
 Four of the eight vertices are put really close to each other to make the
 cube look like a triangle (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-destroyed-wall"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/julia/wallpart_wireframe.PNG
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-destroyed-wall"

\end_inset

A destroyed wall part
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The eight new parts are then given the a position as well as Unity’s component
 Rigidbody, which adds physics to them and will make them fall down and
 look like the big wall has been destroyed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/julia/destruction.png
	width 4.9cm

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename img/julia/destruction2.png
	width 4.9cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Walls destroyed in the game engine’s demo game 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Modularity 
\end_layout

\begin_layout Standard
Due to that Unity’s Mesh class is used together with GameObjects and that
 the scripts acts like components on a gameObjects with every script deriving
 from MonoBehavior; makes the creation and destruction of walls not directly
 transmittable to any other project.
 However, it is fully modular within Unity and could be added as destruction
 of different kinds of cubes with only small modifications.
 Furthermore, since the destructible walls are made of meshes the algorithms
 and classes could be used in projects not using Unity, but with modifications,
 since meshes is something that is built of vertices and triangles put together
 to objects in all kinds of 3D modeling.
 
\end_layout

\begin_layout Section
Integration and testing 
\end_layout

\begin_layout Standard
The six different extensions developed for this game engine were built with
 a modularity focus with the intention for them to be easy to integrate
 and to work as independent components that could be used in any other project
 (at least Unity projects).
 This applies to everything except the command interface which was developed
 to handle the specific messaging and commands used only in this game engine,
 thus not modular.
\end_layout

\begin_layout Standard
The integration was made in iterations with two parts integrated at a time.
 When this was tested and correctly functional a new part was added to this
 until all extension worked together as game engine.
 To test and assure the functionality of the implementations a demo was
 made which is what was used for integration testing.
 However, there was no formal testing done.
 The testing that was done was internally within the group.
 
\end_layout

\begin_layout Section
Tech demo 
\end_layout

\begin_layout Standard
To show off the game engine a tech demo in the form of a game was created,
 this game was named Ten Tips On How To Play With A Hamster.
 The game takes place in a maze where the player controls a ball that is
 rolling around wreaking havoc.
 The maze is populated with dwarves that have different behaviors, they
 are either working, sleeping or running away from the ball.
\end_layout

\begin_layout Standard
The maze will randomly spawn items like powerups.
 If the player controlled ball collects these powerups, the ball enters
 “Destruction mode” meaning it can destroy walls.
 There are also mines that spawn equally randomly.
 If the ball hits one of the mines it will explode throwing the ball up
 in the air, however not harming it.
 The goal of the game is to smash as many of the dwarves as possible.
\end_layout

\begin_layout Standard
The demo features:
\end_layout

\begin_layout Itemize
Pathfinding 
\end_layout

\begin_layout Itemize
Dwarves with different behaviours 
\end_layout

\begin_layout Itemize
Camera effects 
\end_layout

\begin_layout Itemize
Terrain paths 
\end_layout

\begin_layout Itemize
Randomly generated maze 
\end_layout

\begin_layout Itemize
Destructible walls
\end_layout

\begin_layout Subsection
Design 
\end_layout

\begin_layout Standard

\series bold
MazeGenerationScript
\series default
 builds up the maze, which is made of walls that are destructible, upon
 a terrain in a Unity scene.
 Dwarf objects are spawned with the 
\series bold
DwarfManager
\series default
 class, a set number (currently 10) at startup and then one every 10 seconds.
 The AI routines are run at a set interval (currently every 20 frames).
 The dwarves’ behavior is defined using a prioritized selection between
 three different behaviors: flight, when the dwarf sees the ball and the
 ball is close; sleep, when the dwarves are tired and work, when there is
 nothing else to do.
\end_layout

\begin_layout Standard
The player, in the shape of a ball, plays a central part as most of the
 extension parts are dependent on what the player does, where it is and
 how it looks.
 First of all the camera needs to follow the player as well as, for this
 game at least, simulate tilting of the game board handled by the 
\series bold
RotationMaster
\series default
 and 
\series bold
Camera
\series default
 classes together with PlayerScript which receives input from the arrow
 keys.
 Further the terrain takes in input from where the player is, what size
 and shape it has to simulate paths in the ground sent to the 
\series bold
TerrainPath
\series default
 script from PlayerScript.
\end_layout

\begin_layout Standard
Additionally, powerups and mines are spawned randomly in the game world
 and will affect the ball in different ways for example giving the player
 the temporary ability to destroy walls handled by various Spawn scripts
 and Collision scripts.
 
\end_layout

\begin_layout Subsection
Implementation 
\end_layout

\begin_layout Standard
The tech demo shows of most of that which all extensions provide.
 When the game is first started a maze of size 20*20 is being generated,
 surrounded by indestructible walls.
 Then the TileGraphGenerator scan the entire maze to detect the positions
 of the walls and build an internal graph.
 An empty gameobject that contains various script components makes sure
 that dwarves, mines and powerups are being spawned.
\end_layout

\begin_layout Standard
The AI controlled dwarves’ behavior is defined in the DwarfBehavior class,
 of which each dwarf actor has one each.
 The class is a container and creator class behavior trees.
 The root node is a priority selector, which chooses between nodes Flee,
 Work, Sleep, depending on which one has the highest priority.
 The Flee behavior always has the highest priority, but access is blocked
 by a Decorator if the ball is not close enough to be noticed.
 The action nodes use commands from the command interface such as InteractComman
d and MoveCommand.
\end_layout

\begin_layout Standard
The ball is player controlled by adding force to it depending on what keys
 are pressed, and the camera is following it, because it has the player
 script component.
 That player script component also makes sure that a path is made in the
 wake of the ball as it rolls around in the maze.
\end_layout

\begin_layout Standard
When a powerup is being rolled over by the ball, the PickupCommand makes
 sure that the function “startDestroyWallsPowerup” is called on the ball,
 meaning that it can now destroy walls for a couple of seconds.
 When a wall is thereafter hit by the ball, it will cause an explosion and
 also make the wall fall into pieces.
 When the AI controlled dwarves see the ball, they will start to run away
 in a seemingly random fashion, also increasing their movement speed.
 
\end_layout

\begin_layout Subsection
Results 
\end_layout

\begin_layout Standard
It was a good idea to use a game to show the different extensions since
 it gave a good understanding of how the different extensions could be used
 together, additionally it was fun to create a game.
 Further, it gave a nice opportunity to show all extensions.
\end_layout

\begin_layout Standard
The game could be improved further, it would have been a good idea to instead
 of using the PC platform use mobile devices.
 The ball could then be controlled using the accelerometer instead of the
 keyboards.
 This would make the game look and feel more like the traditionally labyrinth
 game.
 However a mobile device do not has the same amount of computational power
 as a computer has so all the extensions might not work properly and give
 the same performance.
 
\end_layout

\begin_layout Section
Screenshots 
\end_layout

\begin_layout Standard
Screenshots from the tech demo representing the game engine.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/screen1.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Time to kill some dwarves!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/screen2.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Damn it! They put a mine there.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/screen3.png
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Destruction mode!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/screen4.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
So much blood.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename img/screen5.png
	width 10cm

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A dwarf working hard.
 And terrain paths! zomg 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance 
\end_layout

\begin_layout Standard
Unity free does not provide any profiling tool to analyze the performance
 during a game session.
 But at least it provides a basic stats panel that can be used to get live
 information about FPS.
 The simulation runs smoothly, around 60 FPS on a standard computer, even
 with a high number of dwarfs (20 for example).
\end_layout

\begin_layout Standard
Some performance improvements have been made by dispatching AI updates.
 For example, the MovementAgent script uses a static integer to give a different
 id to each agent, and frame counter, such that they can update their path
 in different frames.
 The AI behaviour also uses Unity coroutines to update states.
 
\end_layout

\begin_layout Section
Conclusions 
\end_layout

\begin_layout Standard
The tech demo turned out good, it shows all the different extensions in
 a satisfactory way and the group is happy with the results.
\end_layout

\begin_layout Standard
The different extensions have been made in such a way that they as easily
 as possible could be used in other projects within Unity, and some also
 outside of Unity.
 The game engine could be used to feature others games as well as be split
 up and only use the different parts.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
shoudl answer the goals:
\end_layout

\begin_layout Standard
High level of generality: the extensions made for the engine should be easy
 to apply in other projects.
 High level of modularity: the extensions should be as modular as possible
 and not dependant upon each other.
 Extensions should be possible to take away and/or modify without breaking
 the engine.
 .
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "refs"
options "plainnat"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Extension proposals
\end_layout

\end_body
\end_document
